Санёк, привет! 

Вот и новый урок для тебя =)

Задания для него следует будет делать в папке ```lesson-1```

Тут уже будет чуть тяжелее, чем в прошлый раз

В этот раз:
- Ты чуть подробнее разберёшься с тем, как работать с ```git```
- Узнаешь, что такое ```pull request```
- Узнаешь, что такое ```TDD```
- Сам создашь ```Node.js``` проект
- Сам напишешь ```Unit тесты``` для своего кода
- Узнаешь, что такое ```CI-CD```
- И зашаришь за магию автоматизации = )

И так, приступим...

<img src="./assets/1.png"/>

Начальная структура каталога ```lesson-1``` выглядит таким образом, но в процессе твоей работы она изменится. Для себя я создал каталог ```example``` просто, чтобы я там мог что-то делать, чтобы наделать для тебя скриншоты, которые ты видишь здесь. 

- Начнем с работы с ```git```

Что-то ты уже умеешь и знаешь, но возможно что-то новое я тебе сейчас покажу.

Перейду в терминал

<img src="./assets/2.png"/>

Введу команду ```git status```

<img src="./assets/3.png"/>

Тут ```git``` (по скольку я нахожусь в папке, которая является git репозиторием) мне 
выдаёт некоторую информацию о текущем положении дел.

Он говорит мне, что я нахожусь на ветке ```master``` так обычно называют главную ветку репозитория, а также я тут вижу, что у меня есть некоторые не отслеживаемые к изменениям файлы.

По скольку я сейчас только делаю для тебя этот урок, я не хочу, чтобы он находился на ветке мастер. Я выведу новую, чтобы в ней работать

Введу команду ```git checkout -b [наименование ветки]```

<img src="./assets/4.png"/>

Когда ты будешь выполнять свое задание, тебе тоже нужно будет делать все в отдельной ветке!

Кстати, в левом нижнем углу я могу видеть текущую ветку (ветку на которой я нахожусь)

<img src="./assets/5.png"/>

Важно понимать, что такое удаленный(remote) репозиторий и что такое локальный репозиторий.
Наш remote репозиторий был создан на гитхабе и хранится где-то там на серверах, а то что у тебя и меня на компьютерах - это локальные репозитории. Поэтому хоть я и создал новую ветку у себя, в удаленном репозитории она появится только при пуше в репозиторий.

Давай я попробую сохранить промежуточные изменения своей ветки и запушить в наш с тобой репозиторий

<img src="./assets/6.png"/>

```git status``` по прежнему показывет не отслеживаемые изменения текущего файла и всей папки, где я храню картинки 

Я сделаю их отслеживаемыми введу команду ```git add [путь/пути к файлам]```

<img src="./assets/7.png"/>

Я ввел ```git add .``` точка говорит о том, что я добавляю в отслеживаемые все файлы рекурсивно, которые находятся в текущей папке. Теперь они светятся зеленым цветом, гит их отслеживает.

Теперь мне нужно их "закоммитить". Выполню команду ```git commit -m "сообщение к коммиту"```.

<img src="./assets/8.png"/>

"Закоммитил" - теперь изменения и главное история изменений были сохранены в локальном репозитории

Выполню команду ```git log -n 3```, чтобы посмотреть информацию о 3 последних коммитах

<img src="./assets/9.png"/>

Но в удаленном репозитории на ```github``` ничего не появилось

<img src="./assets/10.png"/>

Показывает, что одна ветка только.

Чтобы синхронизировать наши репозитории (локальный и ремоут), надо выполнить команду ```git push```

<img src="./assets/11.png"/>

Эх, не получилось. Потому что гит не понимает с какой веткой в удаленном репозитории производить синхронизацию нашей ветки. Однако сам гит, нам предлагает ввести команду, которая создаст в удаленном репозитории новую ветку ```git push --set-upstream origin lesson-1-creating```.

Введем её!

<img src="./assets/12.png"/>

И у нас все получилось.

<img src="./assets/13.png"/>

Гитхаб теперь показывает, что у нас 2 ветки, и что была создана новая ветка ```lesson-1-creating```. И он даже предлагает нам создать ```pull request```.

<img src="./assets/14.png"/>

Кликнем на зелёную кнопочку и создадим ```pull request``` это запрос на втягивание нашей ветки и всех наших изменений в основную ветку.

<img src="./assets/15.png"/>

Тут можно написать каку-то информацию для ревьювера.

<img src="./assets/16.png"/>

<img src="./assets/17.png"/>

Вот мы и создали наш пул реквест

Так в принципе и производится разработка больших программ и приложений. Большое количество разработчиков делают какую-то функциональность в отдельной ветке, создают ```pull request```ы.
Потом кто-то их все ревьювит и вливает в основную ветку.

Тут мы видим, какие-то ошибки, пишет, что какие-то проверки не прошли =(

Но это не страшно, это просто отрабатывает наш ```CI-CD```, который я сделал еще в самом начале на ```lesson-0```, чтобы твои тесты на твой код запускались автоматически. Просто в этой ветке еще нет твоего кода, поэтому и видем красненькое, потому что тесты падают.

Что же такое ```CI-CD```?

CI/CD (Continuous Integration / Continuous Deployment) — это набор практик и инструментов, направленных на автоматизацию процессов разработки, тестирования и развертывания программного обеспечения. Основная цель CI/CD — ускорить и упростить доставку качественного кода в production, минимизируя ручные операции и снижая вероятность ошибок.

Основные компоненты CI/CD:
- Continuous Integration (CI) — Непрерывная интеграция

- - Разработчики часто объединяют свои изменения в общий репозиторий (например, Git).

- - Каждое изменение автоматически проверяется с помощью сборки и тестов (юнит-тесты, интеграционные тесты и т.д.).

- - Цель: быстро выявлять и устранять конфликты и ошибки, обеспечивая стабильность кода.

- Continuous Delivery (CD) — Непрерывная поставка

- - После успешной сборки и тестирования код автоматически подготавливается к развертыванию в production-среде.

- - Развертывание может быть выполнено вручную (по требованию) или автоматически.

- - Цель: обеспечить готовность кода к выпуску в любой момент.

- Continuous Deployment (CD) — Непрерывное развертывание

- - Расширение Continuous Delivery, где каждое успешное изменение автоматически развертывается в production.

- - Цель: максимально ускорить доставку новых функций и исправлений пользователям.

```
Преимущества CI/CD:
Скорость: Ускорение процессов разработки и выпуска обновлений.
Качество: Раннее обнаружение ошибок благодаря автоматическому тестированию.
Надежность: Минимизация рисков при развертывании.
Автоматизация: Снижение зависимости от ручных операций.
Гибкость: Возможность быстро реагировать на изменения требований.
```

Мы пока остановимся только на ```CI```, без всяких там ```CD```
